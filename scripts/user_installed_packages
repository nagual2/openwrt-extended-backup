#!/bin/sh
# shellcheck shell=sh

set -eu

SCRIPT_PATH=$0

case "$SCRIPT_PATH" in
    */*)
        SCRIPT_SOURCE=$(dirname "$SCRIPT_PATH")
        ;;
    *)
        LOOKUP=$(command -v -- "$SCRIPT_PATH" 2>/dev/null || printf '')
        if [ -n "$LOOKUP" ]; then
            SCRIPT_SOURCE=$(dirname "$LOOKUP")
        else
            SCRIPT_SOURCE='.'
        fi
        ;;
esac

if ! SCRIPT_DIR=$(cd "$SCRIPT_SOURCE" 2>/dev/null && pwd); then
    printf '%s: unable to determine script directory\n' "$(basename "$0")" >&2
    exit 1
fi

# shellcheck source=lib/common.sh
. "$SCRIPT_DIR/lib/common.sh"

common_init "$0"

DEFAULT_STATUS_FILE=${DEFAULT_STATUS_FILE:-'/usr/lib/opkg/status'}
STATUS_FILE=$DEFAULT_STATUS_FILE
STATUS_FILE_IS_CUSTOM=0
USER_INSTALLED_FILE=''
INCLUDE_AUTO_DEPS=0
OUTPUT_PATH=''
EXCLUDE_PATTERNS=''

usage() {
    cat <<EOF
Использование: $PROGRAM [ОПЦИИ]

Опции:
      --status-file PATH         Использовать альтернативный status-файл opkg (по умолчанию $DEFAULT_STATUS_FILE)
      --user-installed-file PATH Добавить пакеты из произвольного списка (по одному имени на строку)
  -x, --exclude PATTERN          Исключить пакеты по шаблону (опцию можно указать несколько раз)
      --include-auto-deps[=BOOL] Включить зависимости с Auto-Installed: yes
      --output PATH              Записать результат в файл вместо stdout (используйте - для stdout)
  -h, --help                     Показать эту справку и выйти
  -V, --version                  Показать версию и выйти
EOF
}

fatal() {
    message=$1
    code=${2:-$EX_SOFTWARE}
    printf '%s: %s\n' "$PROGRAM" "$message" >&2
    exit "$code"
}

append_exclude_pattern() {
    pattern=$1
    if [ -z "$pattern" ]; then
        return
    fi

    if [ -z "$EXCLUDE_PATTERNS" ]; then
        EXCLUDE_PATTERNS=$pattern
    else
        EXCLUDE_PATTERNS=$(printf '%s\n%s' "$EXCLUDE_PATTERNS" "$pattern")
    fi
}

should_exclude() {
    pkg=$1
    if [ -z "$EXCLUDE_PATTERNS" ]; then
        return 1
    fi

    old_ifs=$IFS
    IFS='
'
    for pattern in $EXCLUDE_PATTERNS; do
        if [ -z "$pattern" ]; then
            continue
        fi
        # shellcheck disable=SC2254
        case "$pkg" in
            $pattern)
                IFS=$old_ifs
                return 0
                ;;
        esac
    done
    IFS=$old_ifs
    return 1
}

parse_args() {
    while [ $# -gt 0 ]; do
        arg=$1
        case "$arg" in
            -h | --help)
                usage
                exit "$EX_OK"
                ;;
            -V | --version)
                common_print_version
                exit "$EX_OK"
                ;;
            --status-file)
                if [ $# -lt 2 ]; then
                    fatal 'Опция --status-file требует указать путь' "$EX_USAGE"
                fi
                STATUS_FILE=$2
                STATUS_FILE_IS_CUSTOM=1
                shift
                ;;
            --status-file=*)
                STATUS_FILE=${arg#--status-file=}
                STATUS_FILE_IS_CUSTOM=1
                ;;
            --user-installed-file)
                if [ $# -lt 2 ]; then
                    fatal 'Опция --user-installed-file требует указать путь' "$EX_USAGE"
                fi
                USER_INSTALLED_FILE=$2
                shift
                ;;
            --user-installed-file=*)
                USER_INSTALLED_FILE=${arg#--user-installed-file=}
                ;;
            -x)
                if [ $# -lt 2 ]; then
                    fatal 'Опция -x требует указать шаблон' "$EX_USAGE"
                fi
                append_exclude_pattern "$2"
                shift
                ;;
            --exclude)
                if [ $# -lt 2 ]; then
                    fatal 'Опция --exclude требует указать шаблон' "$EX_USAGE"
                fi
                append_exclude_pattern "$2"
                shift
                ;;
            --exclude=*)
                append_exclude_pattern "${arg#--exclude=}"
                ;;
            --include-auto-deps)
                INCLUDE_AUTO_DEPS=1
                ;;
            --include-auto-deps=*)
                value=${arg#--include-auto-deps=}
                INCLUDE_AUTO_DEPS=$(common_to_bool "$value")
                ;;
            --output)
                if [ $# -lt 2 ]; then
                    fatal 'Опция --output требует указать путь' "$EX_USAGE"
                fi
                OUTPUT_PATH=$2
                shift
                ;;
            --output=*)
                OUTPUT_PATH=${arg#--output=}
                ;;
            *)
                fatal "Неизвестная опция: $arg" "$EX_USAGE"
                ;;
        esac
        shift
    done
}

read_distribution_time() {
    file=$1
    awk '
        /^Installed-Time:[[:space:]]*/ {
            val = $2 + 0
            if (val > 0 && (min == 0 || val < min)) {
                min = val
            }
        }
        END {
            if (min > 0) {
                print min
            }
        }
    ' "$file"
}

collect_status_packages() {
    file=$1
    include_auto=$2
    min_time=$3

    awk -v include_auto="$include_auto" -v min_time="$min_time" '
        function trim(str) {
            gsub(/^[[:space:]]+/, "", str)
            gsub(/[[:space:]]+$/, "", str)
            return str
        }
        function has_token(field, token) {
            pattern = "(^|[[:space:]])" token "([[:space:]]|$)"
            if (field ~ pattern) {
                return 1
            }
            return 0
        }
        BEGIN {
            RS=""
            FS="\n"
            include_flag = include_auto + 0
            reference_time = min_time + 0
        }
        {
            name=""
            status=""
            auto=""
            installed_time=0
            for (i = 1; i <= NF; i++) {
                line = $i
                if (line ~ /^[[:space:]]/) {
                    continue
                }
                colon = index(line, ":")
                if (colon == 0) {
                    continue
                }
                key = substr(line, 1, colon - 1)
                value = substr(line, colon + 1)
                value = trim(value)
                if (key == "Package") {
                    name = value
                } else if (key == "Status") {
                    status = value
                } else if (key == "Auto-Installed") {
                    auto = value
                } else if (key == "Installed-Time") {
                    installed_time = value + 0
                }
            }
            if (name == "") {
                next
            }
            if (!has_token(status, "install")) {
                next
            }
            if (!has_token(status, "user") && !has_token(status, "hold")) {
                next
            }
            auto_flag = 0
            auto_val = tolower(auto)
            if (auto_val == "yes" || auto_val == "true" || auto_val == "1") {
                auto_flag = 1
            }
            if (include_flag == 0 && auto_flag == 1) {
                next
            }
            if (reference_time > 0 && installed_time == reference_time) {
                next
            }
            print name
        }
    ' "$file"
}

collect_opkg_installed() {
    require_cmd opkg
    set +e
    opkg_output=$(opkg list-installed)
    status=$?
    set -e
    if [ "$status" -ne 0 ]; then
        return "$status"
    fi
    printf '%s\n' "$opkg_output"
    return 0
}

read_user_packages() {
    file=$1
    awk '
        {
            gsub(/\r$/, "")
            sub(/[[:space:]]*#.*$/, "")
            gsub(/^[[:space:]]+/, "")
            gsub(/[[:space:]]+$/, "")
            if ($0 != "") {
                print $0
            }
        }
    ' "$file"
}

generate_report() {
    printf '# user-installed opkg packages (%d)\n' "$TOTAL_COUNT"
    printf '# main packages (%d)\n' "$MAIN_COUNT"
    if [ "$MAIN_COUNT" -gt 0 ]; then
        printf '%s\n' "$MAIN_LINES"
    fi
    printf '\n'
    if [ "$LUCI_COUNT" -gt 0 ]; then
        printf '# LuCI translations (%d)\n' "$LUCI_COUNT"
        printf '%s\n' "$LUCI_LINES"
        printf '\n'
    fi
    printf 'opkg update\n'
    if [ "$MAIN_COUNT" -gt 0 ]; then
        printf 'opkg install %s\n' "$MAIN_ARGS"
    fi
    if [ "$LUCI_COUNT" -gt 0 ]; then
        printf 'opkg install %s\n' "$LUCI_ARGS"
    fi
}

parse_args "$@"

if [ -z "$STATUS_FILE" ]; then
    fatal 'Путь к status-файлу не указан' "$EX_USAGE"
fi

if [ -n "$USER_INSTALLED_FILE" ] && [ ! -r "$USER_INSTALLED_FILE" ]; then
    fatal "Не удалось прочитать список вручную установленных пакетов: $USER_INSTALLED_FILE" "$EX_UNAVAILABLE"
fi

STATUS_PACKAGES=''
STATUS_SOURCE='status'
DISTRI_TIME=0

if [ -r "$STATUS_FILE" ]; then
    DISTRI_TIME=$(read_distribution_time "$STATUS_FILE")
    if [ -z "$DISTRI_TIME" ]; then
        DISTRI_TIME=0
    fi
    STATUS_PACKAGES=$(collect_status_packages "$STATUS_FILE" "$INCLUDE_AUTO_DEPS" "$DISTRI_TIME" | LC_ALL=C sort -u)
else
    if [ "$STATUS_FILE_IS_CUSTOM" -eq 1 ]; then
        fatal "Не удалось прочитать status-файл: $STATUS_FILE" "$EX_UNAVAILABLE"
    fi
    STATUS_SOURCE='opkg'
fi

if [ "$STATUS_SOURCE" != 'status' ]; then
    if ! OPKG_LIST=$(collect_opkg_installed); then
        fatal 'Не удалось получить список пакетов через opkg' "$EX_UNAVAILABLE"
    fi
    STATUS_PACKAGES=$(printf '%s\n' "$OPKG_LIST" | awk -F' - ' '
        {
            name = $1
            gsub(/^[[:space:]]+/, "", name)
            gsub(/[[:space:]]+$/, "", name)
            if (name != "") {
                print name
            }
        }
    ' | LC_ALL=C sort -u)
fi

USER_PACKAGES=''
if [ -n "$USER_INSTALLED_FILE" ]; then
    USER_PACKAGES=$(read_user_packages "$USER_INSTALLED_FILE" | LC_ALL=C sort -u)
fi

COMBINED_PACKAGES=$(
    {
        if [ -n "$STATUS_PACKAGES" ]; then
            printf '%s\n' "$STATUS_PACKAGES"
        fi
        if [ -n "$USER_PACKAGES" ]; then
            printf '%s\n' "$USER_PACKAGES"
        fi
    } | awk 'NF' | LC_ALL=C sort -u
)

MAIN_LINES=''
MAIN_ARGS=''
MAIN_COUNT=0
LUCI_LINES=''
LUCI_ARGS=''
LUCI_COUNT=0

if [ -n "$COMBINED_PACKAGES" ]; then
    while IFS= read -r pkg; do
        [ -z "$pkg" ] && continue
        if should_exclude "$pkg"; then
            continue
        fi
        case "$pkg" in
            luci-i18n-*)
                LUCI_COUNT=$((LUCI_COUNT + 1))
                if [ -z "$LUCI_LINES" ]; then
                    LUCI_LINES=$pkg
                else
                    LUCI_LINES=$(printf '%s\n%s' "$LUCI_LINES" "$pkg")
                fi
                if [ -z "$LUCI_ARGS" ]; then
                    LUCI_ARGS=$pkg
                else
                    LUCI_ARGS="$LUCI_ARGS $pkg"
                fi
                ;;
            *)
                MAIN_COUNT=$((MAIN_COUNT + 1))
                if [ -z "$MAIN_LINES" ]; then
                    MAIN_LINES=$pkg
                else
                    MAIN_LINES=$(printf '%s\n%s' "$MAIN_LINES" "$pkg")
                fi
                if [ -z "$MAIN_ARGS" ]; then
                    MAIN_ARGS=$pkg
                else
                    MAIN_ARGS="$MAIN_ARGS $pkg"
                fi
                ;;
        esac
    done <<EOF
$COMBINED_PACKAGES
EOF
fi

TOTAL_COUNT=$((MAIN_COUNT + LUCI_COUNT))

if [ -n "$OUTPUT_PATH" ] && [ "$OUTPUT_PATH" != '-' ]; then
    if ! generate_report >"$OUTPUT_PATH"; then
        fatal "Не удалось записать в файл: $OUTPUT_PATH" "$EX_SOFTWARE"
    fi
else
    generate_report
fi
