#!/bin/sh
# shellcheck shell=sh

set -eu

PROGRAM=$(basename "$0")
SCRIPT_PATH=$0

case "$SCRIPT_PATH" in
    */*)
        SCRIPT_SOURCE=$(dirname "$SCRIPT_PATH")
        ;;
    *)
        LOOKUP=$(command -v -- "$SCRIPT_PATH" 2>/dev/null || printf '')
        if [ -n "$LOOKUP" ]; then
            SCRIPT_SOURCE=$(dirname "$LOOKUP")
        else
            SCRIPT_SOURCE='.'
        fi
        ;;
esac

if ! SCRIPT_DIR=$(cd "$SCRIPT_SOURCE" 2>/dev/null && pwd); then
    printf '%s: unable to determine script directory\n' "$PROGRAM" >&2
    exit 1
fi
PROJECT_ROOT=$(dirname "$SCRIPT_DIR")
VERSION_FILE="${PROJECT_ROOT}/VERSION"
SHARE_VERSION_FILE='/usr/share/openwrt-extended-backup/VERSION'
VERSION_FALLBACK='0.2.0'

if [ -r "$VERSION_FILE" ]; then
    VERSION=$(head -n 1 "$VERSION_FILE")
elif [ -r "$SHARE_VERSION_FILE" ]; then
    VERSION=$(head -n 1 "$SHARE_VERSION_FILE")
fi

if [ -z "${VERSION-}" ]; then
    VERSION=$VERSION_FALLBACK
fi

show_version() {
    printf '%s version %s\n' "$PROGRAM" "$VERSION"
}

EX_OK=0
EX_USAGE=64
EX_UNAVAILABLE=69
EX_SOFTWARE=70

LOG_LEVEL=1
EXPORT_MODE='scp'
EMIT_SCP_CMD=0
SSH_HOST='OpenWrt'
SSH_PORT='22'
SSH_USER='root'
OUT_DIR='/tmp'
ARCHIVE_FILENAME=''
ARCHIVE_PATH=''
REMOVE_ARCHIVE_ON_FAILURE=0

DRY_RUN_ENABLED=0
if [ "${DRY_RUN+x}" = x ]; then
    case "$DRY_RUN" in
        '' | 0 | [Ff][Aa][Ll][Ss][Ee] | [Nn][Oo] | [Oo][Ff][Ff])
            DRY_RUN_ENABLED=0
            ;;
        *)
            DRY_RUN_ENABLED=1
            ;;
    esac
fi

UPLOAD_TARGET=''
UPLOAD_SCHEME=''
UPLOAD_REMOTE_SPEC=''
UPLOAD_USER_HOST=''
UPLOAD_REMOTE_PATH=''
IDENTITY_FILE=''
KNOWN_HOSTS_FILE=''
UPLOAD_RETRY=1

DEFAULT_OVERLAY_DIR='/overlay'
if [ "${OVERLAY_SOURCE+x}" = x ] && [ -n "$OVERLAY_SOURCE" ]; then
    case "$OVERLAY_SOURCE" in
        /)
            OVERLAY_PATH='/'
            ;;
        */)
            OVERLAY_PATH=${OVERLAY_SOURCE%/}
            ;;
        *)
            OVERLAY_PATH=$OVERLAY_SOURCE
            ;;
    esac
    if [ -z "$OVERLAY_PATH" ]; then
        OVERLAY_PATH=$DEFAULT_OVERLAY_DIR
    fi
else
    OVERLAY_PATH=$DEFAULT_OVERLAY_DIR
fi

KSMBD_SHARE_NAME='owrt_archive'
KSMBD_USER='owrt_backup'
KSMBD_PASSWORD=''
KSMBD_SHARE_CREATED=0
KSMBD_SHARE_EXISTED=0

CLEANUP_DONE=0

timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

log_print() {
    threshold=$1
    level=$2
    shift 2

    if [ "$level" = 'ERROR' ] || [ "$LOG_LEVEL" -ge "$threshold" ]; then
        if [ "$#" -gt 0 ]; then
            printf '%s %s %s\n' "$(timestamp)" "$level" "$*" >&2
        else
            printf '%s %s\n' "$(timestamp)" "$level" >&2
        fi
    fi
}

log_info() {
    log_print 1 'INFO' "$@"
}

log_debug() {
    log_print 2 'DEBUG' "$@"
}

log_error() {
    log_print 0 'ERROR' "$@"
}

fatal() {
    message=$1
    code=${2:-$EX_SOFTWARE}
    log_error "$message"
    exit "$code"
}

usage() {
    cat <<'EOF'
Использование: openwrt_full_backup [ОПЦИИ]

Опции:
      --export=MODE         Режим экспорта: scp (по умолчанию), smb или local
      --emit-scp-cmd        Вывести готовую команду scp без дополнительного текста
      --ssh-host HOST       Имя или адрес OpenWrt-хоста (по умолчанию OpenWrt)
      --ssh-port PORT       Порт SSH (по умолчанию 22)
      --ssh-user USER       Пользователь SSH (по умолчанию root)
      --output PATH         Каталог для архива (по умолчанию /tmp)
      --out-dir PATH        Алиас для --output (устар.)
      --upload URL          Загрузить архив на удалённый хост (scp:// или sftp://)
      --identity PATH       Приватный ключ для scp/sftp (например, ~/.ssh/id_ed25519)
      --known-hosts PATH    Пользовательский файл known_hosts для проверки ключей
      --retry COUNT         Количество попыток загрузки (по умолчанию 1)
  -n, --dry-run             План действий без побочных эффектов (архив не создаётся)
  -q, --quiet               Режим тихого вывода (только ошибки)
  -v                        Расширенный вывод (можно указать дважды)
  -h, --help                Показать эту справку и выйти
  -V, --version             Показать версию и выйти
EOF
}

require_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        fatal "Требуемая утилита '$1' недоступна" "$EX_UNAVAILABLE"
    fi
}

to_absolute_path() {
    case "$1" in
        /*)
            printf '%s\n' "$1"
            ;;
        *)
            printf '%s/%s\n' "$(pwd)" "$1"
            ;;
    esac
}

parse_upload_target() {
    target=$1

    if [ -z "$target" ]; then
        fatal 'Опция --upload требует URL (scp:// или sftp://)' "$EX_USAGE"
    fi

    case "$target" in
        scp://*)
            rest=${target#scp://}
            case "$rest" in
                *:*)
                    host_part=${rest%%:*}
                    path_part=${rest#*:}
                    ;;
                *)
                    fatal 'URL для SCP должен содержать host:path' "$EX_USAGE"
                    ;;
            esac
            if [ -z "$host_part" ] || [ -z "$path_part" ]; then
                fatal 'URL для SCP должен содержать host:path' "$EX_USAGE"
            fi
            UPLOAD_TARGET=$target
            UPLOAD_SCHEME='scp'
            UPLOAD_USER_HOST=$host_part
            UPLOAD_REMOTE_PATH=$path_part
            UPLOAD_REMOTE_SPEC="$UPLOAD_USER_HOST:$UPLOAD_REMOTE_PATH"
            ;;
        sftp://*)
            rest=${target#sftp://}
            case "$rest" in
                *:*)
                    host_part=${rest%%:*}
                    path_part=${rest#*:}
                    ;;
                *)
                    fatal 'URL для SFTP должен содержать host:/путь' "$EX_USAGE"
                    ;;
            esac
            if [ -z "$host_part" ] || [ -z "$path_part" ]; then
                fatal 'URL для SFTP должен содержать host:/путь' "$EX_USAGE"
            fi
            UPLOAD_TARGET=$target
            UPLOAD_SCHEME='sftp'
            UPLOAD_USER_HOST=$host_part
            UPLOAD_REMOTE_PATH=$path_part
            UPLOAD_REMOTE_SPEC=$UPLOAD_REMOTE_PATH
            ;;
        *)
            fatal "Неподдерживаемая схема для --upload: $target" "$EX_USAGE"
            ;;
    esac
}

prepare_upload_environment() {
    if [ -z "$UPLOAD_TARGET" ]; then
        return 0
    fi

    case "$UPLOAD_SCHEME" in
        scp)
            require_command scp
            ;;
        sftp)
            require_command sftp
            ;;
    esac

    if [ -n "$IDENTITY_FILE" ] && [ ! -r "$IDENTITY_FILE" ]; then
        fatal "Файл приватного ключа недоступен: $IDENTITY_FILE" "$EX_UNAVAILABLE"
    fi

    if [ -n "$KNOWN_HOSTS_FILE" ] && [ ! -r "$KNOWN_HOSTS_FILE" ]; then
        fatal "Файл known_hosts недоступен: $KNOWN_HOSTS_FILE" "$EX_UNAVAILABLE"
    fi
}

build_scp_preview() {
    command_text='scp'
    if [ "$SSH_PORT" != '22' ]; then
        command_text="$command_text -P $SSH_PORT"
    fi
    if [ -n "$IDENTITY_FILE" ]; then
        command_text="$command_text -i $IDENTITY_FILE"
    fi
    command_text="$command_text -o StrictHostKeyChecking=yes"
    if [ -n "$KNOWN_HOSTS_FILE" ]; then
        command_text="$command_text -o UserKnownHostsFile=$KNOWN_HOSTS_FILE"
    fi
    command_text="$command_text $ARCHIVE_PATH"
    if [ -n "$UPLOAD_REMOTE_SPEC" ]; then
        command_text="$command_text $UPLOAD_REMOTE_SPEC"
    fi
    printf '%s\n' "$command_text"
}

run_with_retries() {
    max_attempts=$1
    shift
    attempt=1
    status=0
    while [ "$attempt" -le "$max_attempts" ]; do
        if "$@"; then
            return 0
        fi
        status=$?
        if [ "$attempt" -ge "$max_attempts" ]; then
            return "$status"
        fi
        attempt=$((attempt + 1))
        log_info "Повторная попытка загрузки ($attempt/$max_attempts)"
    done
    return "$status"
}

perform_upload() {
    if [ -z "$UPLOAD_TARGET" ]; then
        return 0
    fi

    if [ "$UPLOAD_SCHEME" = 'scp' ]; then
        if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
            log_info 'Режим dry-run: готовая команда SCP'
            log_info "$(build_scp_preview)"
            return 0
        fi

        set -- scp
        if [ "$SSH_PORT" != '22' ]; then
            set -- "$@" -P "$SSH_PORT"
        fi
        if [ -n "$IDENTITY_FILE" ]; then
            set -- "$@" -i "$IDENTITY_FILE"
        fi
        set -- "$@" -o StrictHostKeyChecking=yes
        if [ -n "$KNOWN_HOSTS_FILE" ]; then
            set -- "$@" -o "UserKnownHostsFile=$KNOWN_HOSTS_FILE"
        fi
        set -- "$@" "$ARCHIVE_PATH" "$UPLOAD_REMOTE_SPEC"

        log_info "Загрузка архива через SCP: $UPLOAD_REMOTE_SPEC"
        run_with_retries "$UPLOAD_RETRY" "$@"
        status=$?
        return "$status"
    fi

    if [ "$UPLOAD_SCHEME" = 'sftp' ]; then
        if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
            log_info 'Режим dry-run: загрузка через SFTP (команда put)'
            log_info "put \"$ARCHIVE_PATH\" \"$UPLOAD_REMOTE_PATH\""
            return 0
        fi

        batch_file=$(mktemp)
        if [ -z "$batch_file" ]; then
            fatal 'Не удалось создать временный файл для SFTP' "$EX_SOFTWARE"
        fi
        printf 'put "%s" "%s"\n' "$ARCHIVE_PATH" "$UPLOAD_REMOTE_PATH" >"$batch_file"

        set -- sftp
        if [ -n "$IDENTITY_FILE" ]; then
            set -- "$@" -i "$IDENTITY_FILE"
        fi
        if [ "$SSH_PORT" != '22' ]; then
            set -- "$@" -P "$SSH_PORT"
        fi
        set -- "$@" -o StrictHostKeyChecking=yes
        if [ -n "$KNOWN_HOSTS_FILE" ]; then
            set -- "$@" -o "UserKnownHostsFile=$KNOWN_HOSTS_FILE"
        fi
        set -- "$@" -b "$batch_file" "$UPLOAD_USER_HOST"

        log_info "Загрузка архива через SFTP: $UPLOAD_USER_HOST -> $UPLOAD_REMOTE_PATH"
        run_with_retries "$UPLOAD_RETRY" "$@"
        status=$?
        rm -f "$batch_file"
        return "$status"
    fi

    return 0
}

find_share_index_by_name() {
    name=$1
    share_indexes=$(uci -q show ksmbd | sed -n 's/^ksmbd\.@share\[\([0-9]\+\)\]=share$/\1/p')
    for idx in $share_indexes; do
        current=$(uci -q get "ksmbd.@share[$idx].name" 2>/dev/null || printf '')
        if [ "$current" = "$name" ]; then
            printf '%s\n' "$idx"
            return 0
        fi
    done
    return 1
}

remove_smb_share() {
    idx=$(find_share_index_by_name "$KSMBD_SHARE_NAME" 2>/dev/null || printf '')
    if [ -n "$idx" ]; then
        uci delete "ksmbd.@share[$idx]" >/dev/null 2>&1 || true
        uci commit ksmbd >/dev/null 2>&1 || true
        if [ -x /etc/init.d/ksmbd ]; then
            /etc/init.d/ksmbd restart >/dev/null 2>&1 || true
        fi
    fi
}

cleanup() {
    status=$1

    if [ "$CLEANUP_DONE" -eq 1 ]; then
        exit "$status"
    fi
    CLEANUP_DONE=1

    set +e

    if [ "$status" -ne 0 ] && [ "$REMOVE_ARCHIVE_ON_FAILURE" -eq 1 ] && [ -n "$ARCHIVE_PATH" ]; then
        rm -f "$ARCHIVE_PATH"
    fi

    if [ "$status" -ne 0 ] && [ "$EXPORT_MODE" = 'smb' ] && [ "$KSMBD_SHARE_CREATED" -eq 1 ] && [ "$KSMBD_SHARE_EXISTED" -eq 0 ]; then
        remove_smb_share
    fi

    exit "$status"
}

trap 'cleanup $?' EXIT
trap 'cleanup 130' INT
trap 'cleanup 143' TERM

parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            --export=*)
                EXPORT_MODE=${1#--export=}
                ;;
            --export)
                shift || fatal 'Опция --export требует аргумент' "$EX_USAGE"
                EXPORT_MODE=$1
                ;;
            --emit-scp-cmd)
                EMIT_SCP_CMD=1
                ;;
            --ssh-host=*)
                SSH_HOST=${1#--ssh-host=}
                ;;
            --ssh-host)
                shift || fatal 'Опция --ssh-host требует аргумент' "$EX_USAGE"
                SSH_HOST=$1
                ;;
            --ssh-port=*)
                SSH_PORT=${1#--ssh-port=}
                ;;
            --ssh-port)
                shift || fatal 'Опция --ssh-port требует аргумент' "$EX_USAGE"
                SSH_PORT=$1
                ;;
            --ssh-user=*)
                SSH_USER=${1#--ssh-user=}
                ;;
            --ssh-user)
                shift || fatal 'Опция --ssh-user требует аргумент' "$EX_USAGE"
                SSH_USER=$1
                ;;
            --output=*)
                OUT_DIR=${1#--output=}
                ;;
            --output)
                shift || fatal 'Опция --output требует аргумент' "$EX_USAGE"
                OUT_DIR=$1
                ;;
            --out-dir=*)
                OUT_DIR=${1#--out-dir=}
                ;;
            --out-dir)
                shift || fatal 'Опция --out-dir требует аргумент' "$EX_USAGE"
                OUT_DIR=$1
                ;;
            --upload=*)
                parse_upload_target "${1#--upload=}"
                ;;
            --upload)
                shift || fatal 'Опция --upload требует URL' "$EX_USAGE"
                parse_upload_target "$1"
                ;;
            --identity=*)
                IDENTITY_FILE=${1#--identity=}
                ;;
            --identity)
                shift || fatal 'Опция --identity требует путь к файлу' "$EX_USAGE"
                IDENTITY_FILE=$1
                ;;
            --known-hosts=*)
                KNOWN_HOSTS_FILE=${1#--known-hosts=}
                ;;
            --known-hosts)
                shift || fatal 'Опция --known-hosts требует путь к файлу' "$EX_USAGE"
                KNOWN_HOSTS_FILE=$1
                ;;
            --retry=*)
                UPLOAD_RETRY=${1#--retry=}
                ;;
            --retry)
                shift || fatal 'Опция --retry требует положительное число' "$EX_USAGE"
                UPLOAD_RETRY=$1
                ;;
            -n | --dry-run)
                DRY_RUN_ENABLED=1
                ;;
            --dry-run=*)
                value=${1#--dry-run=}
                case "$value" in
                    '' | 0 | [Ff][Aa][Ll][Ss][Ee] | [Nn][Oo] | [Oo][Ff][Ff])
                        DRY_RUN_ENABLED=0
                        ;;
                    *)
                        DRY_RUN_ENABLED=1
                        ;;
                esac
                ;;
            -v)
                if [ "$LOG_LEVEL" -lt 2 ]; then
                    LOG_LEVEL=$((LOG_LEVEL + 1))
                fi
                ;;
            -q | --quiet)
                LOG_LEVEL=0
                ;;
            -h | --help)
                usage
                exit "$EX_OK"
                ;;
            -V | --version)
                show_version
                exit "$EX_OK"
                ;;
            --)
                shift
                break
                ;;
            -*)
                fatal "Неизвестная опция: $1" "$EX_USAGE"
                ;;
            *)
                fatal "Неожиданный аргумент: $1" "$EX_USAGE"
                ;;
        esac
        shift
    done

    if [ $# -gt 0 ]; then
        fatal "Неожиданный аргумент: $1" "$EX_USAGE"
    fi

    case "$EXPORT_MODE" in
        scp | smb | local) ;;
        *)
            fatal "Неподдерживаемый режим экспорта: $EXPORT_MODE" "$EX_USAGE"
            ;;
    esac

    case "$SSH_PORT" in
        '' | *[!0-9]*)
            fatal 'Порт SSH должен быть целым числом' "$EX_USAGE"
            ;;
    esac

    case "$UPLOAD_RETRY" in
        '' | *[!0-9]*)
            fatal 'Опция --retry должна быть положительным числом' "$EX_USAGE"
            ;;
        0)
            fatal 'Опция --retry должна быть >= 1' "$EX_USAGE"
            ;;
    esac

    OUT_DIR=$(to_absolute_path "$OUT_DIR")
}

sanitize_token() {
    token=$1
    printf '%s\n' "$token" | tr ' ' '_' | tr -c 'A-Za-z0-9_.-' '_'
}

get_firmware_tag() {
    if [ -r /etc/openwrt_release ]; then
        desc=$(grep "^DISTRIB_DESCRIPTION='" /etc/openwrt_release 2>/dev/null | head -n 1)
        if [ -n "$desc" ]; then
            value=$(printf '%s' "$desc" | cut -d"'" -f2)
            if [ -n "$value" ]; then
                sanitize_token "$value"
                return 0
            fi
        fi
    fi
    if command -v uname >/dev/null 2>&1; then
        sanitize_token "$(uname -n)"
        return 0
    fi
    printf 'OpenWrt\n'
}

prepare_environment() {
    require_command tar
    require_command date

    if [ "$EXPORT_MODE" = 'scp' ]; then
        log_debug 'Режим экспорта: SCP'
    elif [ "$EXPORT_MODE" = 'smb' ]; then
        log_debug 'Режим экспорта: SMB'
    else
        log_debug 'Режим экспорта: local'
    fi

    if [ "$DRY_RUN_ENABLED" -eq 0 ]; then
        if ! mkdir -p "$OUT_DIR"; then
            fatal "Не удалось создать каталог: $OUT_DIR" "$EX_SOFTWARE"
        fi

        if [ ! -w "$OUT_DIR" ]; then
            fatal "Каталог недоступен для записи: $OUT_DIR" "$EX_SOFTWARE"
        fi

        if [ ! -d "$OVERLAY_PATH" ]; then
            fatal "Каталог для архивации не найден: $OVERLAY_PATH" "$EX_SOFTWARE"
        fi
    fi
}

create_archive() {
    firmware=$(get_firmware_tag)
    timestamp_label=$(date +'%Y-%m-%d_%H-%M-%S')
    ARCHIVE_FILENAME="fullbackup_${firmware}_${timestamp_label}.tar.gz"
    ARCHIVE_PATH="${OUT_DIR%/}/$ARCHIVE_FILENAME"

    if [ -e "$ARCHIVE_PATH" ]; then
        fatal "Файл уже существует: $ARCHIVE_PATH" "$EX_SOFTWARE"
    fi

    case "$OVERLAY_PATH" in
        /)
            overlay_base='/'
            exclude_work='/work'
            exclude_run='/upper/run'
            exclude_os_release='/upper/etc/os-release'
            exclude_usr_os_release='/upper/usr/lib/os-release'
            ;;
        *)
            overlay_base=${OVERLAY_PATH%/}
            if [ -z "$overlay_base" ]; then
                overlay_base='/overlay'
            fi
            exclude_work="$overlay_base/work"
            exclude_run="$overlay_base/upper/run"
            exclude_os_release="$overlay_base/upper/etc/os-release"
            exclude_usr_os_release="$overlay_base/upper/usr/lib/os-release"
            ;;
    esac

    if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
        log_info 'Режим dry-run: действия выполняются без побочных эффектов'
        log_info "Режим dry-run: архив не создавался (запланированный путь: $ARCHIVE_PATH)"
        return 0
    fi

    log_info "Создание архива: $ARCHIVE_PATH"
    REMOVE_ARCHIVE_ON_FAILURE=1

    if ! tar -czpf "$ARCHIVE_PATH" \
        --preserve-permissions \
        --same-owner \
        --exclude="$exclude_work" \
        --exclude="$exclude_run" \
        --exclude="$exclude_os_release" \
        --exclude="$exclude_usr_os_release" \
        "$overlay_base"; then
        fatal 'Не удалось создать архив' "$EX_SOFTWARE"
    fi

    REMOVE_ARCHIVE_ON_FAILURE=0

    log_info "Архив сохранён: $ARCHIVE_PATH"

    if command -v du >/dev/null 2>&1; then
        size=$(du -h "$ARCHIVE_PATH" 2>/dev/null | awk '{print $1}' | head -n 1)
        if [ -n "$size" ]; then
            log_info "Размер архива: $size"
        fi
    fi
}

ensure_ksmbd_dependencies() {
    require_command ksmbd.adduser
    require_command uci
    if [ ! -x /etc/init.d/ksmbd ]; then
        fatal 'Служба ksmbd недоступна (нет /etc/init.d/ksmbd)' "$EX_UNAVAILABLE"
    fi

    if command -v ksmbd.status >/dev/null 2>&1; then
        log_debug 'Обнаружен ksmbd.status'
    fi
}

generate_password() {
    if command -v tr >/dev/null 2>&1; then
        candidate=$(tr -dc 'A-Za-z0-9' </dev/urandom 2>/dev/null | head -c 16)
        if [ -n "$candidate" ]; then
            printf '%s\n' "$candidate"
            return 0
        fi
    fi
    printf 'owrt_%s\n' "$(date +'%H%M%S')"
}

setup_smb_export() {
    if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
        log_info 'Режим dry-run: SMB-экспорт не настраивается'
        return 0
    fi

    ensure_ksmbd_dependencies

    if [ -z "$KSMBD_PASSWORD" ]; then
        KSMBD_PASSWORD=$(generate_password)
    fi

    log_info "Обновление пользователя SMB: $KSMBD_USER"
    ksmbd.adduser "$KSMBD_USER" -p "$KSMBD_PASSWORD"

    share_index=$(find_share_index_by_name "$KSMBD_SHARE_NAME" 2>/dev/null || printf '')
    if [ -n "$share_index" ]; then
        KSMBD_SHARE_EXISTED=1
        target_index=$share_index
        log_debug "Используется существующая шара @$share_index"
    else
        log_info "Создание SMB-шары: $KSMBD_SHARE_NAME"
        if ! uci add ksmbd share >/dev/null 2>&1; then
            fatal 'Не удалось создать раздел ksmbd share' "$EX_SOFTWARE"
        fi
        target_index='-1'
        KSMBD_SHARE_EXISTED=0
    fi

    uci set "ksmbd.@share[$target_index].name=$KSMBD_SHARE_NAME"
    uci set "ksmbd.@share[$target_index].path=$OUT_DIR"
    uci set "ksmbd.@share[$target_index].guest_ok='no'"
    uci set "ksmbd.@share[$target_index].read_only='yes'"
    uci set "ksmbd.@share[$target_index].create_mask='0644'"
    uci set "ksmbd.@share[$target_index].dir_mask='0755'"
    uci set "ksmbd.@share[$target_index].users=$KSMBD_USER"
    uci commit ksmbd

    KSMBD_SHARE_CREATED=1

    if ! /etc/init.d/ksmbd restart >/dev/null 2>&1; then
        fatal 'Не удалось перезапустить службу ksmbd' "$EX_SOFTWARE"
    fi

    host=$(get_hostname)
    ip=$(get_primary_ip)

    if [ -n "$ip" ]; then
        log_info "SMB-шара доступна по адресу \\\\$ip\\\\$KSMBD_SHARE_NAME"
    fi
    log_info "SMB-шара доступна по имени \\\\$host\\\\$KSMBD_SHARE_NAME"
    log_info "Имя пользователя: $KSMBD_USER"
    log_info "Пароль: $KSMBD_PASSWORD"
}

get_hostname() {
    if command -v uci >/dev/null 2>&1; then
        host=$(uci -q get system.@system[0].hostname 2>/dev/null || printf '')
        if [ -n "$host" ]; then
            printf '%s\n' "$host"
            return 0
        fi
    fi
    if command -v hostname >/dev/null 2>&1; then
        hostname 2>/dev/null
        return 0
    fi
    printf '%s\n' "$SSH_HOST"
}

get_primary_ip() {
    if ! command -v ip >/dev/null 2>&1; then
        return 1
    fi

    if ip -4 addr show br-lan >/dev/null 2>&1; then
        candidate=$(ip -4 addr show br-lan | awk '/inet / {print $2}' | cut -d/ -f1 | head -n 1)
        if [ -n "$candidate" ]; then
            printf '%s\n' "$candidate"
            return 0
        fi
    fi

    candidate=$(ip -4 addr show | awk '/inet / && $2 !~ /^127\./ {print $2}' | cut -d/ -f1 | head -n 1)
    if [ -n "$candidate" ]; then
        printf '%s\n' "$candidate"
        return 0
    fi
    return 1
}

emit_scp_instruction() {
    scp_opts=''
    if [ "$SSH_PORT" != '22' ]; then
        scp_opts="-P $SSH_PORT"
    fi

    command_text="scp"
    if [ -n "$scp_opts" ]; then
        command_text="$command_text $scp_opts"
    fi
    command_text="$command_text $SSH_USER@$SSH_HOST:$ARCHIVE_PATH <destination>"

    log_info "Готовая команда SCP: $command_text"

    if [ "$EMIT_SCP_CMD" -eq 1 ]; then
        printf '%s\n' "$command_text"
    fi
}

parse_args "$@"

prepare_environment
prepare_upload_environment

create_archive

perform_upload
upload_status=$?
if [ "$upload_status" -ne 0 ]; then
    exit "$upload_status"
fi

case "$EXPORT_MODE" in
    scp)
        emit_scp_instruction
        ;;
    smb)
        setup_smb_export
        ;;
    local)
        if [ "$DRY_RUN_ENABLED" -eq 0 ]; then
            log_info "Архив сохранён в $ARCHIVE_PATH"
        fi
        ;;
esac

exit "$EX_OK"
