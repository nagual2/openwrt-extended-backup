#!/bin/sh
# shellcheck shell=sh

SCRIPT_PATH=$0

case "$SCRIPT_PATH" in
    */*)
        SCRIPT_SOURCE=$(dirname "$SCRIPT_PATH")
        ;;
    *)
        LOOKUP=$(command -v -- "$SCRIPT_PATH" 2>/dev/null || printf '')
        if [ -n "$LOOKUP" ]; then
            SCRIPT_SOURCE=$(dirname "$LOOKUP")
        else
            SCRIPT_SOURCE='.'
        fi
        ;;
esac

if ! SCRIPT_DIR=$(cd "$SCRIPT_SOURCE" 2>/dev/null && pwd); then
    printf '%s: unable to determine script directory\n' "$(basename "$0")" >&2
    exit 1
fi

# shellcheck source=lib/common.sh
. "$SCRIPT_DIR/lib/common.sh"

common_init "$0"







: "${LOG_LEVEL:=1}"
EXPORT_MODE='scp'
EMIT_SCP_CMD=0
SSH_HOST='OpenWrt'
SSH_PORT='22'
SSH_USER='root'
OUT_DIR='/tmp'
ARCHIVE_FILENAME=''
ARCHIVE_PATH=''
REMOVE_ARCHIVE_ON_FAILURE=0

DRY_RUN_ENABLED=0
if [ "${DRY_RUN+x}" = x ]; then
    case "$DRY_RUN" in
        '' | 0 | [Ff][Aa][Ll][Ss][Ee] | [Nn][Oo] | [Oo][Ff][Ff])
            DRY_RUN_ENABLED=0
            ;;
        *)
            DRY_RUN_ENABLED=1
            ;;
    esac
fi

UPLOAD_TARGET=''
UPLOAD_SCHEME=''
UPLOAD_REMOTE_SPEC=''
UPLOAD_USER_HOST=''
UPLOAD_REMOTE_PATH=''
IDENTITY_FILE=''
KNOWN_HOSTS_FILE=''
UPLOAD_RETRY=1

DEFAULT_OVERLAY_DIR='/overlay'
if [ "${OVERLAY_SOURCE+x}" = x ] && [ -n "$OVERLAY_SOURCE" ]; then
    case "$OVERLAY_SOURCE" in
        /)
            OVERLAY_PATH='/'
            ;;
        */)
            OVERLAY_PATH=${OVERLAY_SOURCE%/}
            ;;
        *)
            OVERLAY_PATH=$OVERLAY_SOURCE
            ;;
    esac
    if [ -z "$OVERLAY_PATH" ]; then
        OVERLAY_PATH=$DEFAULT_OVERLAY_DIR
    fi
else
    OVERLAY_PATH=$DEFAULT_OVERLAY_DIR
fi

KSMBD_SHARE_NAME='owrt_archive'
KSMBD_USER='owrt_backup'
KSMBD_PASSWORD=''
KSMBD_SHARE_CREATED=0
KSMBD_SHARE_EXISTED=0

KSMBD_SERVICE=${KSMBD_INIT_SCRIPT:-/etc/init.d/ksmbd}







usage() {
    cat <<EOF
Использование: $PROGRAM [ОПЦИИ]

Опции:
      --export=MODE         Режим экспорта: scp (по умолчанию), smb или local
      --emit-scp-cmd        Вывести готовую команду scp без дополнительного текста
      --ssh-host HOST       Имя или адрес OpenWrt-хоста (по умолчанию OpenWrt)
      --ssh-port PORT       Порт SSH (по умолчанию 22)
      --ssh-user USER       Пользователь SSH (по умолчанию root)
      --output PATH         Каталог для архива (по умолчанию /tmp)
      --out-dir PATH        Алиас для --output (устар.)
      --upload URL          Загрузить архив на удалённый хост (scp:// или sftp://)
      --identity PATH       Приватный ключ для scp/sftp (например, ~/.ssh/id_ed25519)
      --known-hosts PATH    Пользовательский файл known_hosts для проверки ключей
      --retry COUNT         Количество попыток загрузки (по умолчанию 1)
  -n, --dry-run             План действий без побочных эффектов (архив не создаётся)
  -q, --quiet               Режим тихого вывода (только ошибки)
  -v                        Расширенный вывод (можно указать дважды)
  -h, --help                Показать эту справку и выйти
  -V, --version             Показать версию и выйти
EOF
}


to_absolute_path() {
    case "$1" in
        /*)
            printf '%s\n' "$1"
            ;;
        *)
            printf '%s/%s\n' "$(pwd)" "$1"
            ;;
    esac
}

parse_upload_target() {
    target=$1

    if [ -z "$target" ]; then
        die 'Опция --upload требует URL (scp:// или sftp://)' "$EX_USAGE"
    fi

    case "$target" in
        scp://*)
            rest=${target#scp://}
            case "$rest" in
                *:*)
                    host_part=${rest%%:*}
                    path_part=${rest#*:}
                    ;;
                *)
                    die 'URL для SCP должен содержать host:path' "$EX_USAGE"
                    ;;
            esac
            if [ -z "$host_part" ] || [ -z "$path_part" ]; then
                die 'URL для SCP должен содержать host:path' "$EX_USAGE"
            fi
            UPLOAD_TARGET=$target
            UPLOAD_SCHEME='scp'
            UPLOAD_USER_HOST=$host_part
            UPLOAD_REMOTE_PATH=$path_part
            UPLOAD_REMOTE_SPEC="$UPLOAD_USER_HOST:$UPLOAD_REMOTE_PATH"
            ;;
        sftp://*)
            rest=${target#sftp://}
            case "$rest" in
                *:*)
                    host_part=${rest%%:*}
                    path_part=${rest#*:}
                    ;;
                *)
                    die 'URL для SFTP должен содержать host:/путь' "$EX_USAGE"
                    ;;
            esac
            if [ -z "$host_part" ] || [ -z "$path_part" ]; then
                die 'URL для SFTP должен содержать host:/путь' "$EX_USAGE"
            fi
            UPLOAD_TARGET=$target
            UPLOAD_SCHEME='sftp'
            UPLOAD_USER_HOST=$host_part
            UPLOAD_REMOTE_PATH=$path_part
            UPLOAD_REMOTE_SPEC=$UPLOAD_REMOTE_PATH
            ;;
        *)
            die "Неподдерживаемая схема для --upload: $target" "$EX_USAGE"
            ;;
    esac
}

prepare_upload_environment() {
    if [ -z "$UPLOAD_TARGET" ]; then
        return 0
    fi

    case "$UPLOAD_SCHEME" in
        scp)
            require_cmd scp
            ;;
        sftp)
            require_cmd sftp
            ;;
    esac

    if [ -n "$IDENTITY_FILE" ] && [ ! -r "$IDENTITY_FILE" ]; then
        die "Файл приватного ключа недоступен: $IDENTITY_FILE" "$EX_UNAVAILABLE"
    fi

    if [ -n "$KNOWN_HOSTS_FILE" ] && [ ! -r "$KNOWN_HOSTS_FILE" ]; then
        die "Файл known_hosts недоступен: $KNOWN_HOSTS_FILE" "$EX_UNAVAILABLE"
    fi
}

build_scp_preview() {
    command_text='scp'
    if [ "$SSH_PORT" != '22' ]; then
        command_text="$command_text -P $SSH_PORT"
    fi
    if [ -n "$IDENTITY_FILE" ]; then
        command_text="$command_text -i $IDENTITY_FILE"
    fi
    command_text="$command_text -o StrictHostKeyChecking=yes"
    if [ -n "$KNOWN_HOSTS_FILE" ]; then
        command_text="$command_text -o UserKnownHostsFile=$KNOWN_HOSTS_FILE"
    fi
    command_text="$command_text $ARCHIVE_PATH"
    if [ -n "$UPLOAD_REMOTE_SPEC" ]; then
        command_text="$command_text $UPLOAD_REMOTE_SPEC"
    fi
    printf '%s\n' "$command_text"
}

run_with_retries() {
    max_attempts=$1
    shift
    attempt=1
    status=0
    while [ "$attempt" -le "$max_attempts" ]; do
        if "$@"; then
            return 0
        fi
        status=$?
        if [ "$attempt" -ge "$max_attempts" ]; then
            return "$status"
        fi
        attempt=$((attempt + 1))
        log_info "Повторная попытка загрузки ($attempt/$max_attempts)"
    done
    return "$status"
}

perform_upload() {
    if [ -z "$UPLOAD_TARGET" ]; then
        return 0
    fi

    if [ "$UPLOAD_SCHEME" = 'scp' ]; then
        if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
            log_info 'Режим dry-run: готовая команда SCP'
            log_info "$(build_scp_preview)"
            return 0
        fi

        set -- scp
        if [ "$SSH_PORT" != '22' ]; then
            set -- "$@" -P "$SSH_PORT"
        fi
        if [ -n "$IDENTITY_FILE" ]; then
            set -- "$@" -i "$IDENTITY_FILE"
        fi
        set -- "$@" -o StrictHostKeyChecking=yes
        if [ -n "$KNOWN_HOSTS_FILE" ]; then
            set -- "$@" -o "UserKnownHostsFile=$KNOWN_HOSTS_FILE"
        fi
        set -- "$@" "$ARCHIVE_PATH" "$UPLOAD_REMOTE_SPEC"

        log_info "Загрузка архива через SCP: $UPLOAD_REMOTE_SPEC"
        run_with_retries "$UPLOAD_RETRY" "$@"
        status=$?
        return "$status"
    fi

    if [ "$UPLOAD_SCHEME" = 'sftp' ]; then
        if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
            log_info 'Режим dry-run: загрузка через SFTP (команда put)'
            log_info "put \"$ARCHIVE_PATH\" \"$UPLOAD_REMOTE_PATH\""
            return 0
        fi

        batch_file=$(mktemp "$(common_tmpdir)/sftp-batch.XXXXXX")
        if [ -z "$batch_file" ]; then
            die 'Не удалось создать временный файл для SFTP' "$EX_SOFTWARE"
        fi
        printf 'put "%s" "%s"\n' "$ARCHIVE_PATH" "$UPLOAD_REMOTE_PATH" >"$batch_file"

        set -- sftp
        if [ -n "$IDENTITY_FILE" ]; then
            set -- "$@" -i "$IDENTITY_FILE"
        fi
        if [ "$SSH_PORT" != '22' ]; then
            set -- "$@" -P "$SSH_PORT"
        fi
        set -- "$@" -o StrictHostKeyChecking=yes
        if [ -n "$KNOWN_HOSTS_FILE" ]; then
            set -- "$@" -o "UserKnownHostsFile=$KNOWN_HOSTS_FILE"
        fi
        set -- "$@" -b "$batch_file" "$UPLOAD_USER_HOST"

        log_info "Загрузка архива через SFTP: $UPLOAD_USER_HOST -> $UPLOAD_REMOTE_PATH"
        run_with_retries "$UPLOAD_RETRY" "$@"
        status=$?
        rm -f "$batch_file"
        return "$status"
    fi

    return 0
}

find_share_index_by_name() {
    name=$1
    share_indexes=$(uci -q show ksmbd | sed -n 's/^ksmbd\.@share\[\([0-9]\+\)\]=share$/\1/p')
    for idx in $share_indexes; do
        current=$(uci -q get "ksmbd.@share[$idx].name" 2>/dev/null || printf '')
        if [ "$current" = "$name" ]; then
            printf '%s\n' "$idx"
            return 0
        fi
    done
    return 1
}

remove_smb_share() {
    idx=$(find_share_index_by_name "$KSMBD_SHARE_NAME" 2>/dev/null || printf '')
    if [ -n "$idx" ]; then
        uci delete "ksmbd.@share[$idx]" >/dev/null 2>&1 || true
        uci commit ksmbd >/dev/null 2>&1 || true
        if [ -x "$KSMBD_SERVICE" ]; then
            "$KSMBD_SERVICE" restart >/dev/null 2>&1 || true
        fi
    fi
}

backup_cleanup() {
    status=$1

    if [ "$status" -ne 0 ] && [ "$REMOVE_ARCHIVE_ON_FAILURE" -eq 1 ] && [ -n "$ARCHIVE_PATH" ]; then
        rm -f "$ARCHIVE_PATH"
    fi

    if [ "$status" -ne 0 ] && [ "$EXPORT_MODE" = 'smb' ] && [ "$KSMBD_SHARE_CREATED" -eq 1 ] && [ "$KSMBD_SHARE_EXISTED" -eq 0 ]; then
        remove_smb_share
    fi
}

common_add_cleanup backup_cleanup

parse_args() {
    OPTIND=1

    while getopts '-:hVqvn' opt; do
        case "$opt" in
            h)
                usage
                exit "$EX_OK"
                ;;
            V)
                common_print_version
                exit "$EX_OK"
                ;;
            q)
                LOG_LEVEL=0
                ;;
            v)
                if [ "$LOG_LEVEL" -lt 2 ]; then
                    LOG_LEVEL=$((LOG_LEVEL + 1))
                fi
                ;;
            n)
                DRY_RUN_ENABLED=1
                ;;
            -)
                if [ -z "$OPTARG" ]; then
                    break
                fi
                case "$OPTARG" in
                    help)
                        usage
                        exit "$EX_OK"
                        ;;
                    version)
                        common_print_version
                        exit "$EX_OK"
                        ;;
                    quiet)
                        LOG_LEVEL=0
                        ;;
                    quiet=*)
                        value=${OPTARG#quiet=}
                        if [ "$(common_to_bool "$value")" -eq 1 ]; then
                            LOG_LEVEL=0
                        fi
                        ;;
                    verbose)
                        if [ "$LOG_LEVEL" -lt 2 ]; then
                            LOG_LEVEL=$((LOG_LEVEL + 1))
                        fi
                        ;;
                    verbose=*)
                        value=${OPTARG#verbose=}
                        if [ "$(common_to_bool "$value")" -eq 1 ] && [ "$LOG_LEVEL" -lt 2 ]; then
                            LOG_LEVEL=$((LOG_LEVEL + 1))
                        fi
                        ;;
                    dry-run)
                        DRY_RUN_ENABLED=1
                        ;;
                    dry-run=*)
                        value=${OPTARG#dry-run=}
                        DRY_RUN_ENABLED=$(common_to_bool "$value")
                        ;;
                    export)
                        EXPORT_MODE=$(common_getopts_consume_value 'export' "$@")
                        ;;
                    export=*)
                        EXPORT_MODE=${OPTARG#export=}
                        ;;
                    emit-scp-cmd)
                        EMIT_SCP_CMD=1
                        ;;
                    emit-scp-cmd=*)
                        value=${OPTARG#emit-scp-cmd=}
                        EMIT_SCP_CMD=$(common_to_bool "$value")
                        ;;
                    ssh-host)
                        SSH_HOST=$(common_getopts_consume_value 'ssh-host' "$@")
                        ;;
                    ssh-host=*)
                        SSH_HOST=${OPTARG#ssh-host=}
                        ;;
                    ssh-port)
                        SSH_PORT=$(common_getopts_consume_value 'ssh-port' "$@")
                        ;;
                    ssh-port=*)
                        SSH_PORT=${OPTARG#ssh-port=}
                        ;;
                    ssh-user)
                        SSH_USER=$(common_getopts_consume_value 'ssh-user' "$@")
                        ;;
                    ssh-user=*)
                        SSH_USER=${OPTARG#ssh-user=}
                        ;;
                    output)
                        OUT_DIR=$(common_getopts_consume_value 'output' "$@")
                        ;;
                    output=*)
                        OUT_DIR=${OPTARG#output=}
                        ;;
                    out-dir)
                        OUT_DIR=$(common_getopts_consume_value 'out-dir' "$@")
                        ;;
                    out-dir=*)
                        OUT_DIR=${OPTARG#out-dir=}
                        ;;
                    upload)
                        value=$(common_getopts_consume_value 'upload' "$@")
                        parse_upload_target "$value"
                        ;;
                    upload=*)
                        parse_upload_target "${OPTARG#upload=}"
                        ;;
                    identity)
                        IDENTITY_FILE=$(common_getopts_consume_value 'identity' "$@")
                        ;;
                    identity=*)
                        IDENTITY_FILE=${OPTARG#identity=}
                        ;;
                    known-hosts)
                        KNOWN_HOSTS_FILE=$(common_getopts_consume_value 'known-hosts' "$@")
                        ;;
                    known-hosts=*)
                        KNOWN_HOSTS_FILE=${OPTARG#known-hosts=}
                        ;;
                    retry)
                        UPLOAD_RETRY=$(common_getopts_consume_value 'retry' "$@")
                        ;;
                    retry=*)
                        UPLOAD_RETRY=${OPTARG#retry=}
                        ;;
                    *)
                        die "Неизвестная опция: --$OPTARG" "$EX_USAGE"
                        ;;
                esac
                ;;
            :)
                die "Опция -$OPTARG требует аргумент" "$EX_USAGE"
                ;;
            ?)
                die "Неизвестная опция: -$OPTARG" "$EX_USAGE"
                ;;
        esac
    done

    shift $((OPTIND - 1))

    if [ $# -gt 0 ] && [ "$1" = '--' ]; then
        shift
    fi

    if [ $# -gt 0 ]; then
        die "Неожиданный аргумент: $1" "$EX_USAGE"
    fi

    case "$EXPORT_MODE" in
        scp | smb | local) ;;
        *)
            die "Неподдерживаемый режим экспорта: $EXPORT_MODE" "$EX_USAGE"
            ;;
    esac

    case "$SSH_PORT" in
        '' | *[!0-9]*)
            die 'Порт SSH должен быть целым числом' "$EX_USAGE"
            ;;
    esac

    case "$UPLOAD_RETRY" in
        '' | *[!0-9]*)
            die 'Опция --retry должна быть положительным числом' "$EX_USAGE"
            ;;
        0)
            die 'Опция --retry должна быть >= 1' "$EX_USAGE"
            ;;
    esac

    OUT_DIR=$(to_absolute_path "$OUT_DIR")
}

sanitize_token() {
    token=$1
    printf '%s\n' "$token" | tr ' ' '_' | tr -c 'A-Za-z0-9_.-' '_'
}

get_firmware_tag() {
    release_desc=$(common_openwrt_description 2>/dev/null || printf '')
    if [ -n "$release_desc" ]; then
        sanitize_token "$release_desc"
        return 0
    fi

    if command -v uname >/dev/null 2>&1; then
        sanitize_token "$(uname -n)"
        return 0
    fi

    printf '%s\n' 'OpenWrt'
}

prepare_environment() {
    require_cmd tar
    require_cmd date

    if [ "$EXPORT_MODE" = 'scp' ]; then
        log_debug 'Режим экспорта: SCP'
    elif [ "$EXPORT_MODE" = 'smb' ]; then
        log_debug 'Режим экспорта: SMB'
    else
        log_debug 'Режим экспорта: local'
    fi

    if [ "$DRY_RUN_ENABLED" -eq 0 ]; then
        if ! mkdir -p "$OUT_DIR"; then
            die "Не удалось создать каталог: $OUT_DIR" "$EX_SOFTWARE"
        fi

        if [ ! -w "$OUT_DIR" ]; then
            die "Каталог недоступен для записи: $OUT_DIR" "$EX_SOFTWARE"
        fi

        if [ ! -d "$OVERLAY_PATH" ]; then
            die "Каталог для архивации не найден: $OVERLAY_PATH" "$EX_SOFTWARE"
        fi
    fi
}

create_archive() {
    firmware=$(get_firmware_tag)
    timestamp_label=$(date +'%Y-%m-%d_%H-%M-%S')
    ARCHIVE_FILENAME="fullbackup_${firmware}_${timestamp_label}.tar.gz"
    ARCHIVE_PATH="${OUT_DIR%/}/$ARCHIVE_FILENAME"

    if [ -e "$ARCHIVE_PATH" ]; then
        die "Файл уже существует: $ARCHIVE_PATH" "$EX_SOFTWARE"
    fi

    case "$OVERLAY_PATH" in
        /)
            overlay_base='/'
            exclude_work='/work'
            exclude_run='/upper/run'
            exclude_os_release='/upper/etc/os-release'
            exclude_usr_os_release='/upper/usr/lib/os-release'
            ;;
        *)
            overlay_base=${OVERLAY_PATH%/}
            if [ -z "$overlay_base" ]; then
                overlay_base='/overlay'
            fi
            exclude_work="$overlay_base/work"
            exclude_run="$overlay_base/upper/run"
            exclude_os_release="$overlay_base/upper/etc/os-release"
            exclude_usr_os_release="$overlay_base/upper/usr/lib/os-release"
            ;;
    esac

    if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
        log_info 'Режим dry-run: действия выполняются без побочных эффектов'
        log_info "Режим dry-run: архив не создавался (запланированный путь: $ARCHIVE_PATH)"
        return 0
    fi

    log_info "Создание архива: $ARCHIVE_PATH"
    REMOVE_ARCHIVE_ON_FAILURE=1

    if ! tar -czpf "$ARCHIVE_PATH" \
        --preserve-permissions \
        --same-owner \
        --exclude="$exclude_work" \
        --exclude="$exclude_run" \
        --exclude="$exclude_os_release" \
        --exclude="$exclude_usr_os_release" \
        "$overlay_base"; then
        die 'Не удалось создать архив' "$EX_SOFTWARE"
    fi

    REMOVE_ARCHIVE_ON_FAILURE=0

    log_info "Архив сохранён: $ARCHIVE_PATH"

    if command -v du >/dev/null 2>&1; then
        size=$(du -h "$ARCHIVE_PATH" 2>/dev/null | awk '{print $1}' | head -n 1)
        if [ -n "$size" ]; then
            log_info "Размер архива: $size"
        fi
    fi
}

ensure_ksmbd_dependencies() {
    require_cmd ksmbd.adduser
    require_cmd uci
    if [ ! -x "$KSMBD_SERVICE" ]; then
        die "Служба ksmbd недоступна (нет $KSMBD_SERVICE)" "$EX_UNAVAILABLE"
    fi

    if command -v ksmbd.status >/dev/null 2>&1; then
        log_debug 'Обнаружен ksmbd.status'
    fi
}

generate_password() {
    if command -v tr >/dev/null 2>&1; then
        candidate=$(tr -dc 'A-Za-z0-9' </dev/urandom 2>/dev/null | head -c 16)
        if [ -n "$candidate" ]; then
            printf '%s\n' "$candidate"
            return 0
        fi
    fi
    printf 'owrt_%s\n' "$(date +'%H%M%S')"
}

setup_smb_export() {
    if [ "$DRY_RUN_ENABLED" -eq 1 ]; then
        log_info 'Режим dry-run: SMB-экспорт не настраивается'
        return 0
    fi

    ensure_ksmbd_dependencies

    if [ -z "$KSMBD_PASSWORD" ]; then
        KSMBD_PASSWORD=$(generate_password)
    fi

    log_info "Обновление пользователя SMB: $KSMBD_USER"
    ksmbd.adduser "$KSMBD_USER" -p "$KSMBD_PASSWORD"

    share_index=$(find_share_index_by_name "$KSMBD_SHARE_NAME" 2>/dev/null || printf '')
    if [ -n "$share_index" ]; then
        KSMBD_SHARE_EXISTED=1
        target_index=$share_index
        log_debug "Используется существующая шара @$share_index"
    else
        log_info "Создание SMB-шары: $KSMBD_SHARE_NAME"
        if ! uci add ksmbd share >/dev/null 2>&1; then
            die 'Не удалось создать раздел ksmbd share' "$EX_SOFTWARE"
        fi
        target_index='-1'
        KSMBD_SHARE_EXISTED=0
    fi

    uci set "ksmbd.@share[$target_index].name=$KSMBD_SHARE_NAME"
    uci set "ksmbd.@share[$target_index].path=$OUT_DIR"
    uci set "ksmbd.@share[$target_index].guest_ok='no'"
    uci set "ksmbd.@share[$target_index].read_only='yes'"
    uci set "ksmbd.@share[$target_index].create_mask='0644'"
    uci set "ksmbd.@share[$target_index].dir_mask='0755'"
    uci set "ksmbd.@share[$target_index].users=$KSMBD_USER"
    uci commit ksmbd

    KSMBD_SHARE_CREATED=1

    if ! "$KSMBD_SERVICE" restart >/dev/null 2>&1; then
        die 'Не удалось перезапустить службу ksmbd' "$EX_SOFTWARE"
    fi

    host=$(get_hostname)
    ip=$(get_primary_ip)

    if [ -n "$ip" ]; then
        log_info "SMB-шара доступна по адресу \\\\$ip\\\\$KSMBD_SHARE_NAME"
    fi
    log_info "SMB-шара доступна по имени \\\\$host\\\\$KSMBD_SHARE_NAME"
    log_info "Имя пользователя: $KSMBD_USER"
    log_info "Пароль: $KSMBD_PASSWORD"
}

get_hostname() {
    if command -v uci >/dev/null 2>&1; then
        host=$(uci -q get system.@system[0].hostname 2>/dev/null || printf '')
        if [ -n "$host" ]; then
            printf '%s\n' "$host"
            return 0
        fi
    fi
    if command -v hostname >/dev/null 2>&1; then
        hostname 2>/dev/null
        return 0
    fi
    printf '%s\n' "$SSH_HOST"
}

get_primary_ip() {
    if ! command -v ip >/dev/null 2>&1; then
        return 1
    fi

    if ip -4 addr show br-lan >/dev/null 2>&1; then
        candidate=$(ip -4 addr show br-lan | awk '/inet / {print $2}' | cut -d/ -f1 | head -n 1)
        if [ -n "$candidate" ]; then
            printf '%s\n' "$candidate"
            return 0
        fi
    fi

    candidate=$(ip -4 addr show | awk '/inet / && $2 !~ /^127\./ {print $2}' | cut -d/ -f1 | head -n 1)
    if [ -n "$candidate" ]; then
        printf '%s\n' "$candidate"
        return 0
    fi
    return 1
}

emit_scp_instruction() {
    scp_opts=''
    if [ "$SSH_PORT" != '22' ]; then
        scp_opts="-P $SSH_PORT"
    fi

    command_text="scp"
    if [ -n "$scp_opts" ]; then
        command_text="$command_text $scp_opts"
    fi
    command_text="$command_text $SSH_USER@$SSH_HOST:$ARCHIVE_PATH <destination>"

    log_info "Готовая команда SCP: $command_text"

    if [ "$EMIT_SCP_CMD" -eq 1 ]; then
        printf '%s\n' "$command_text"
    fi
}

parse_args "$@"

prepare_environment
prepare_upload_environment

create_archive

perform_upload
upload_status=$?
if [ "$upload_status" -ne 0 ]; then
    exit "$upload_status"
fi

case "$EXPORT_MODE" in
    scp)
        emit_scp_instruction
        ;;
    smb)
        setup_smb_export
        ;;
    local)
        if [ "$DRY_RUN_ENABLED" -eq 0 ]; then
            log_info "Архив сохранён в $ARCHIVE_PATH"
        fi
        ;;
esac

exit "$EX_OK"
