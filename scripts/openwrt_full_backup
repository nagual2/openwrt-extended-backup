#!/bin/sh
# shellcheck shell=sh

SCRIPT_PATH=$0

case "$SCRIPT_PATH" in
    */*)
        SCRIPT_SOURCE=$(dirname "$SCRIPT_PATH")
        ;;
    *)
        LOOKUP=$(command -v -- "$SCRIPT_PATH" 2>/dev/null || printf '')
        if [ -n "$LOOKUP" ]; then
            SCRIPT_SOURCE=$(dirname "$LOOKUP")
        else
            SCRIPT_SOURCE='.'
        fi
        ;;
esac

if ! SCRIPT_DIR=$(cd "$SCRIPT_SOURCE" 2>/dev/null && pwd); then
    printf '%s: unable to determine script directory\n' "$(basename "$0")" >&2
    exit 1
fi

# shellcheck source=lib/common.sh
. "$SCRIPT_DIR/lib/common.sh"

common_init "$0"

DRY_RUN=0
OUTPUT_DIR='/tmp'
OVERLAY_PATH='/overlay'
SMB_ENABLED=0

ARCHIVE_FILENAME=''
ARCHIVE_PATH=''
REMOVE_ARCHIVE_ON_FAILURE=0
TAR_EXCLUDE_FILE=''

SMB_SHARE_NAME='owrt_archive'
SMB_USER='owrt_backup'
SMB_PASSWORD=''
if [ "${KSMBD_PASSWORD+x}" = x ]; then
    SMB_PASSWORD=$KSMBD_PASSWORD
fi
SMB_SHARE_CREATED=0
SMB_SHARE_EXISTED=0
SMB_USER_CREATED=0
KSMBD_SERVICE=${KSMBD_INIT_SCRIPT:-/etc/init.d/ksmbd}

usage() {
    cat <<EOF
Использование: $PROGRAM [ОПЦИИ]

Опции:
      --output PATH       Каталог для архива (по умолчанию /tmp)
      --overlay DIR       Каталог overlay для архивации (по умолчанию /overlay)
      --export=smb        Поднять временную SMB-шару (ksmbd)
      --dry-run           Проверка без создания архива
  -h, --help              Показать эту справку и выйти
  -V, --version           Показать версию и выйти
EOF
}

resolve_directory() {
    dir=$1
    if [ -z "$dir" ]; then
        die 'Путь не может быть пустым' "$EX_USAGE"
    fi

    case "$dir" in
        /*)
            abs=$dir
            ;;
        *)
            abs=$(printf '%s/%s' "$(pwd)" "$dir")
            ;;
    esac

    case "$abs" in
        /)
            printf '/\n'
            ;;
        */)
            printf '%s\n' "${abs%/}"
            ;;
        *)
            printf '%s\n' "$abs"
            ;;
    esac
}

set_export_mode() {
    mode=$1
    case "$mode" in
        '' | local | none)
            SMB_ENABLED=0
            ;;
        smb)
            SMB_ENABLED=1
            ;;
        *)
            die "Неподдерживаемый режим экспорта: $mode" "$EX_USAGE"
            ;;
    esac
}

parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            --output)
                if [ $# -eq 1 ]; then
                    die 'Опция --output требует путь' "$EX_USAGE"
                fi
                shift
                OUTPUT_DIR=$1
                ;;
            --output=*)
                OUTPUT_DIR=${1#--output=}
                ;;
            --overlay)
                if [ $# -eq 1 ]; then
                    die 'Опция --overlay требует путь' "$EX_USAGE"
                fi
                shift
                OVERLAY_PATH=$1
                ;;
            --overlay=*)
                OVERLAY_PATH=${1#--overlay=}
                ;;
            --export)
                if [ $# -eq 1 ]; then
                    die 'Опция --export требует значение' "$EX_USAGE"
                fi
                shift
                set_export_mode "$1"
                ;;
            --export=*)
                set_export_mode "${1#--export=}"
                ;;
            --dry-run)
                DRY_RUN=1
                ;;
            -h | --help)
                usage
                exit "$EX_OK"
                ;;
            -V | --version)
                common_print_version
                exit "$EX_OK"
                ;;
            --)
                shift
                break
                ;;
            -* )
                die "Неизвестная опция: $1" "$EX_USAGE"
                ;;
            *)
                die "Неожиданный аргумент: $1" "$EX_USAGE"
                ;;
        esac
        shift
    done

    if [ $# -gt 0 ]; then
        die "Неожиданный аргумент: $1" "$EX_USAGE"
    fi
}

get_firmware_tag() {
    release_desc=$(common_openwrt_description 2>/dev/null || printf '')
    if [ -n "$release_desc" ]; then
        common_sanitize_token "$release_desc"
        return 0
    fi

    if command -v uname >/dev/null 2>&1; then
        common_sanitize_token "$(uname -n)"
        return 0
    fi

    printf 'OpenWrt\n'
}

build_archive_metadata() {
    firmware=$(get_firmware_tag)
    timestamp=$(date +'%Y-%m-%d_%H-%M-%S')
    ARCHIVE_FILENAME="fullbackup_${firmware}_${timestamp}.tar.gz"

    output_base=${OUTPUT_DIR%/}
    if [ -z "$output_base" ]; then
        output_base='/'
    fi

    ARCHIVE_PATH="$output_base/$ARCHIVE_FILENAME"

    if [ -e "$ARCHIVE_PATH" ]; then
        if [ "$DRY_RUN" -eq 1 ]; then
            log_warn "Файл уже существует и будет перезаписан при обычном запуске: $ARCHIVE_PATH"
        else
            die "Файл уже существует: $ARCHIVE_PATH" "$EX_SOFTWARE"
        fi
    fi
}

remove_tar_exclude_file() {
    # shellcheck disable=SC2034
    status=$1
    if [ -n "$TAR_EXCLUDE_FILE" ] && [ -f "$TAR_EXCLUDE_FILE" ]; then
        rm -f "$TAR_EXCLUDE_FILE"
    fi
    TAR_EXCLUDE_FILE=''
}

backup_cleanup() {
    status=$1

    if [ "$status" -ne 0 ] && [ "$REMOVE_ARCHIVE_ON_FAILURE" -eq 1 ] && [ -n "$ARCHIVE_PATH" ]; then
        rm -f "$ARCHIVE_PATH" >/dev/null 2>&1 || true
    fi

    if [ "$SMB_ENABLED" -eq 1 ] && [ "$DRY_RUN" -eq 0 ] && [ "$status" -ne 0 ]; then
        if [ "$SMB_SHARE_CREATED" -eq 1 ] && [ "$SMB_SHARE_EXISTED" -eq 0 ]; then
            remove_smb_share
        fi
        if [ "$SMB_USER_CREATED" -eq 1 ] && command -v ksmbd.deluser >/dev/null 2>&1; then
            ksmbd.deluser "$SMB_USER" >/dev/null 2>&1 || true
        fi
    fi
}

common_add_cleanup backup_cleanup

prepare_environment() {
    require_cmd tar
    require_cmd date

    OUTPUT_DIR=$(resolve_directory "$OUTPUT_DIR")
    OVERLAY_PATH=$(resolve_directory "$OVERLAY_PATH")

    if [ ! -d "$OVERLAY_PATH" ]; then
        die "Каталог для архивации не найден: $OVERLAY_PATH" "$EX_SOFTWARE"
    fi

    if [ "$DRY_RUN" -eq 0 ]; then
        if ! mkdir -p "$OUTPUT_DIR"; then
            die "Не удалось создать каталог: $OUTPUT_DIR" "$EX_SOFTWARE"
        fi
        if [ ! -w "$OUTPUT_DIR" ]; then
            die "Каталог недоступен для записи: $OUTPUT_DIR" "$EX_SOFTWARE"
        fi
    fi
}

build_tar_exclude_file() {
    overlay_parent=$1
    overlay_name=$2

    exclude_file=$(mktemp "$(common_tmpdir)/tar-exclude.XXXXXX")
    if [ -z "$exclude_file" ]; then
        die 'Не удалось подготовить список исключений для tar' "$EX_SOFTWARE"
    fi

    {
        printf '%s/work\n' "$overlay_name"
        printf '%s/work/*\n' "$overlay_name"
        printf '%s/upper/run\n' "$overlay_name"
        printf '%s/upper/run/*\n' "$overlay_name"
        printf '%s/upper/etc/os-release\n' "$overlay_name"
        printf '%s/upper/usr/lib/os-release\n' "$overlay_name"
    } >"$exclude_file"

    if ! (
        cd "$overlay_parent" 2>/dev/null &&
            find "$overlay_name" \
                \( -path "$overlay_name/work" -o -path "$overlay_name/work/*" \
                -o -path "$overlay_name/upper/run" -o -path "$overlay_name/upper/run/*" \
                -o -path "$overlay_name/upper/etc/os-release" \
                -o -path "$overlay_name/upper/usr/lib/os-release" \) -prune \
                -o \( -type s -o -type p -o -type b -o -type c \) -print
    ) >>"$exclude_file"; then
        die 'Не удалось подготовить список исключений для tar' "$EX_SOFTWARE"
    fi

    TAR_EXCLUDE_FILE=$exclude_file
    common_add_cleanup remove_tar_exclude_file
}

print_scp_hint() {
    host=$(get_hostname)
    if [ -z "$host" ]; then
        host='router'
    fi
    log_info "Скопируйте архив на локальную машину: scp root@${host}:$ARCHIVE_PATH <destination>"
}

create_archive() {
    build_archive_metadata

    log_info "Исходный каталог: $OVERLAY_PATH"
    log_info "Каталог назначения: $OUTPUT_DIR"

    if [ "$DRY_RUN" -eq 1 ]; then
        log_info 'Режим dry-run: архив не создавался'
        log_info "Режим dry-run: запланированный путь: $ARCHIVE_PATH"
        return 0
    fi

    overlay_parent=$(dirname "$OVERLAY_PATH")
    overlay_name=$(basename "$OVERLAY_PATH")

    build_tar_exclude_file "$overlay_parent" "$overlay_name"

    REMOVE_ARCHIVE_ON_FAILURE=1
    if ! (
        cd "$overlay_parent" 2>/dev/null &&
            tar -czpf "$ARCHIVE_PATH" \
                --numeric-owner \
                --preserve-permissions \
                --same-owner \
                -X "$TAR_EXCLUDE_FILE" \
                "$overlay_name"
    ); then
        die 'Не удалось создать архив' "$EX_SOFTWARE"
    fi

    REMOVE_ARCHIVE_ON_FAILURE=0
    log_info "Архив сохранён: $ARCHIVE_PATH"

    if command -v du >/dev/null 2>&1; then
        size=$(du -h "$ARCHIVE_PATH" 2>/dev/null | awk 'NR==1 {print $1}')
        if [ -n "$size" ]; then
            log_info "Размер архива: $size"
        fi
    fi

    print_scp_hint
}

generate_password() {
    if command -v tr >/dev/null 2>&1; then
        candidate=$(tr -dc 'A-Za-z0-9' </dev/urandom 2>/dev/null | head -c 16)
        if [ -n "$candidate" ]; then
            printf '%s\n' "$candidate"
            return 0
        fi
    fi
    printf 'owrt_%s\n' "$(date +'%H%M%S')"
}

ensure_ksmbd_dependencies() {
    require_cmd ksmbd.adduser
    require_cmd ksmbd.deluser
    require_cmd uci
    if [ ! -x "$KSMBD_SERVICE" ]; then
        die "Служба ksmbd недоступна (нет $KSMBD_SERVICE)" "$EX_UNAVAILABLE"
    fi
}

find_share_index_by_name() {
    name=$1
    share_indexes=$(uci -q show ksmbd | sed -n 's/^ksmbd\.@share\[\([0-9]\+\)\]=share$/\1/p')
    for idx in $share_indexes; do
        current=$(uci -q get "ksmbd.@share[$idx].name" 2>/dev/null || printf '')
        if [ "$current" = "$name" ]; then
            printf '%s\n' "$idx"
            return 0
        fi
    done
    return 1
}

remove_smb_share() {
    idx=$(find_share_index_by_name "$SMB_SHARE_NAME" 2>/dev/null || printf '')
    if [ -n "$idx" ]; then
        uci delete "ksmbd.@share[$idx]" >/dev/null 2>&1 || true
        uci commit ksmbd >/dev/null 2>&1 || true
        if [ -x "$KSMBD_SERVICE" ]; then
            "$KSMBD_SERVICE" restart >/dev/null 2>&1 || true
        fi
    fi
}

get_hostname() {
    if command -v uci >/dev/null 2>&1; then
        host=$(uci -q get system.@system[0].hostname 2>/dev/null || printf '')
        if [ -n "$host" ]; then
            printf '%s\n' "$host"
            return 0
        fi
    fi
    if command -v hostname >/dev/null 2>&1; then
        hostname 2>/dev/null
        return 0
    fi
    printf 'OpenWrt\n'
}

get_primary_ip() {
    if ! command -v ip >/dev/null 2>&1; then
        return 1
    fi

    if ip -4 addr show br-lan >/dev/null 2>&1; then
        candidate=$(ip -4 addr show br-lan | awk '/inet / {print $2}' | cut -d/ -f1 | head -n 1)
        if [ -n "$candidate" ]; then
            printf '%s\n' "$candidate"
            return 0
        fi
    fi

    candidate=$(ip -4 addr show | awk '/inet / && $2 !~ /^127\./ {print $2}' | cut -d/ -f1 | head -n 1)
    if [ -n "$candidate" ]; then
        printf '%s\n' "$candidate"
        return 0
    fi
    return 1
}

setup_smb_export() {
    if [ "$SMB_ENABLED" -ne 1 ]; then
        return 0
    fi

    if [ "$DRY_RUN" -eq 1 ]; then
        log_info 'Режим dry-run: SMB-экспорт не настраивается'
        return 0
    fi

    ensure_ksmbd_dependencies

    if [ -z "$SMB_PASSWORD" ]; then
        SMB_PASSWORD=$(generate_password)
    fi

    log_info "Настройка SMB-шары: $SMB_SHARE_NAME"
    if ksmbd.adduser "$SMB_USER" -p "$SMB_PASSWORD"; then
        SMB_USER_CREATED=1
    else
        die 'Не удалось создать пользователя SMB' "$EX_SOFTWARE"
    fi

    share_index=$(find_share_index_by_name "$SMB_SHARE_NAME" 2>/dev/null || printf '')
    if [ -n "$share_index" ]; then
        SMB_SHARE_EXISTED=1
        target_index=$share_index
    else
        SMB_SHARE_EXISTED=0
        target_index='-1'
    fi

    uci set "ksmbd.@share[$target_index].name=$SMB_SHARE_NAME"
    uci set "ksmbd.@share[$target_index].path=$OUTPUT_DIR"
    uci set "ksmbd.@share[$target_index].guest_ok=no"
    uci set "ksmbd.@share[$target_index].read_only=yes"
    uci set "ksmbd.@share[$target_index].create_mask=0644"
    uci set "ksmbd.@share[$target_index].dir_mask=0755"
    uci set "ksmbd.@share[$target_index].users=$SMB_USER"
    uci commit ksmbd

    SMB_SHARE_CREATED=1

    if ! "$KSMBD_SERVICE" restart >/dev/null 2>&1; then
        die 'Не удалось перезапустить службу ksmbd' "$EX_SOFTWARE"
    fi

    host=$(get_hostname)
    ip=$(get_primary_ip)

    if [ -n "$ip" ]; then
        log_info "SMB-шара доступна по адресу \\\\${ip}\\\\$SMB_SHARE_NAME"
    fi
    log_info "SMB-шара доступна по имени \\\\${host}\\\\$SMB_SHARE_NAME"
    log_info "Имя пользователя: $SMB_USER"
    log_info "Пароль: $SMB_PASSWORD"
    log_info 'После копирования отключите шару и удалите пользователя: ksmbd.deluser owrt_backup'
}

parse_args "$@"

prepare_environment
create_archive
setup_smb_export

exit "$EX_OK"
